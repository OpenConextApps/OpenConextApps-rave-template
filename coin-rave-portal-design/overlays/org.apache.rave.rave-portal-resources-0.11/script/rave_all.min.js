/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var rave = rave || (function () {
    var providerMap = {};
    var widgetByIdMap = {};
    var widgetsByRegionIdMap = {};
    var context = "";
    var clientMessages = {};
    var openAjaxHub;

    /**
     * Separate sub-namespace for isolating UI functions and state management
     *
     * NOTE: The UI implementation has dependencies on jQuery and jQuery UI
     */
    var ui = (function () {
        var TEXT_FIELD_TEMPLATE = "<tr>{prefLabelTemplate}<td><input type='text' id='{name}' name='{name}' value='{value}' class='{class}'></td></tr>";
        var CHECKBOX_TEMPLATE = "<tr>{prefLabelTemplate}<td><input type='checkbox' id='{name}' name='{name}' class='{class}' {checked}></td></tr>";
        var SELECT_FIELD_TEMPLATE = "<tr>{prefLabelTemplate}<td><select id='{name}' name='{name}' class='{class}'>{options}</select></td></tr>";
        var SELECT_OPTION_TEMPLATE = "<option value='{value}' {selected}>{displayValue}</option>";
        var TEXTAREA_TEMPLATE = "<tr>{prefLabelTemplate}<td><textarea id='{name}' name='{name}' rows='5' cols='12' class='{class}'>{value}</textarea></td></tr>";
        var HIDDEN_FIELD_TEMPLATE = "<input type='hidden' id='{name}' name='{name}' value='{value}'>";
        var PREFS_SAVE_BUTTON_TEMPLATE = "<button type='button' id='{elementId}'>{buttonText}</button>";
        var PREFS_CANCEL_BUTTON_TEMPLATE = "<button type='button' id='{elementId}'>{buttonText}</button>";

        var NAME_REGEX = /{name}/g;
        var VALUE_REGEX = /{value}/g;
        var OPTIONS_REGEX = /{options}/g;
        var SELECTED_REGEX = /{selected}/g;
        var CHECKED_REGEX = /{checked}/g;
        var DISPLAY_VALUE_REGEX = /{displayValue}/g;
        var PIPE_REGEX = /\|/g;
        var ELEMENT_ID_REGEX = /{elementId}/g;
        var PREF_LABEL_TEMPLATE_REGEX = /{prefLabelTemplate}/g;
        var CLASS_REGEX = /{class}/g;
        var BUTTON_TEXT_REGEX = /{buttonText}/g;

        var WIDGET_TOGGLE_DISPLAY_COLLAPSED_HTML = '<i class="icon-chevron-down"></i>';
        var WIDGET_TOGGLE_DISPLAY_NORMAL_HTML = '<i class="icon-chevron-up"></i>';

        var WIDGET_PREFS_LABEL_CLASS = "widget-prefs-label";
        var WIDGET_PREFS_LABEL_REQUIRED_CLASS = "widget-prefs-label-required";
        var WIDGET_PREFS_INPUT_CLASS = "widget-prefs-input";
        var WIDGET_PREFS_INPUT_REQUIRED_CLASS = "widget-prefs-input-required";
        var WIDGET_PREFS_INPUT_FAILED_VALIDATION = "widget-prefs-input-failed-validation";

        var WIDGET_ICON_BASE_CLASS = "ui-icon";
        var WIDGET_BTN_MINIMIZE_CLASS = "ui-icon-arrowthick-1-sw";
        var WIDGET_TOGGLE_DISPLAY_COLLAPSED = "ui-icon-triangle-1-e";
        var WIDGET_TOGGLE_DISPLAY_NORMAL = "ui-icon-triangle-1-s";
        var POPUPS = {
            sidebar:{
                name:"sidebar",
                containerSelector:'.popup.slideout',
                contentSelector:'.slideout-content',
                markup:'<div class="popup slideout"><div class="slideout-content"></div></div>',
                initialize:function (container) {
                    container.find(this.contentSelector).data('popupType', this.name);
                    container.show("slide", { direction:"right" }, 'fast');
                    $('body').addClass('modal-open');
                    $('body').append('<div class="modal-backdrop fade in"></div>');
                },
                cleanup:function (content) {
                    var container = content.parents(this.containerSelector);
                    container.hide("slide", { direction:"right" }, 'fast', function () {
                        container.detach();
                        $('body').removeClass('modal-open');
                        $('.modal-backdrop').remove();
                    });
                },
                singleton:true
            },
            dialog:{
                name:"dialog",
                containerSelector:'.popup.dialog',
                contentSelector:'.modal-body',
                markup:'<div class="popup dialog modal fade"><div class="modal-body"></div></div>',
                initialize:function (container) {
                    container.find(this.contentSelector).data('popupType', this.name);
                    var cfg = {
                    };
                    container.modal(cfg);

                    container.on('hidden', function () {
                        container.detach();
                    })
                },
                cleanup:function (content) {
                    var container = content.parents(this.containerSelector);

                    container.modal('hide');
                },
                singleton:false
            },
            modal_dialog:{
                name:"modal_dialog",
                containerSelector:'.popup.modal_dialog',
                contentSelector:'.modal-body',
                markup:'<div class="popup modal_dialog modal fade"><div class="modal-body"></div></div>',
                initialize:function (container) {
                    container.find(this.contentSelector).data('popupType', this.name);
                    var cfg = {
                        keyboard:false,
                        backdrop:'static',
                        show:true
                    };
                    container.modal(cfg);

                    container.on('hidden', function () {
                        container.detach();
                    })
                },
                cleanup:function (content) {
                    var container = content.parents(this.containerSelector);

                    container.modal('hide');
                },
                singleton:true
            },
            float:false,
            tab:false
        };

        // variable to store whether or not the
        // client is a mobile device
        var mobileState = false;

        function WIDGET_PREFS_EDIT_BUTTON(regionWidgetId) {
            return "widget-" + regionWidgetId + "-prefs";
        }

        function WIDGET_PREFS_SAVE_BUTTON(regionWidgetId) {
            return "widget-" + regionWidgetId + "-prefs-save-button";
        }

        function WIDGET_PREFS_CANCEL_BUTTON(regionWidgetId) {
            return "widget-" + regionWidgetId + "-prefs-cancel-button";
        }

        function WIDGET_PREFS_CONTENT(regionWidgetId) {
            return "widget-" + regionWidgetId + "-prefs-content";
        }

        var uiState = {
            widget:null,
            currentRegion:null,
            targetRegion:null,
            targetIndex:null
        };

        function setMobileState(mobileState) {
            this.mobileState = mobileState;
        }

        function getMobileState() {
            return this.mobileState;
        }

        function init() {
            // initialize the sortable regions
            getNonLockedRegions().sortable({
                connectWith:'.region', // defines which regions are dnd-able
                scroll:true, // whether to scroll the window if the user goes outside the areas
                opacity:0.5, // the opacity of the object being dragged
                revert:true, // smooth snap animation
                cursor:'move', // the cursor to show while dnd
                handle:'.widget-title-bar', // the draggable handle
                forcePlaceholderSize:true, // size the placeholder to the size of the widget
                tolerance:'pointer', // change dnd drop zone on mouse-over
                start:dragStart, // event listener for drag start
                stop:dragStop, // event listener for drag stop
                over:dragOver // event listener for drag over
            });
            initWidgetUI();
        }

        function dragStart(event, ui) {
            adjustRowRegionsHeights();
            var $regions = getNonLockedRegions();
            // highlight the draggable regions
            $regions.addClass("regionDragging");
            // remove invisible border so nothing moves
            $regions.removeClass("regionNonDragging");

            uiState.widget = ui.item.children(".widget").get(0);
            uiState.currentRegion = ui.item.parent().get(0);

            //for every drag operation, create an overlay for each iframe
            //to prevent the iframe from intercepting mouse events
            //which kills drag performance
            $(".widget").each(function (index, element) {
                addOverlay($(element));
            });
        }

        function dragStop(event, ui) {
            var $regions = getNonLockedRegions();

            // reset padding to 0 after drag on all rows
            if ($(".widgetRow").length) {
                var rows = $regions.find(".widgetRow");
                rows.each(resetRowsRegionsHeight);
            }

            // remove the draggable regions visible border
            $regions.removeClass("regionDragging");
            // add an invisible border so nothing moves
            $regions.addClass("regionNonDragging");

            $(".dnd-overlay").remove();
            //Fixes a bug where the jQuery style attribute remains set in chrome
            ui.item.attr("style", "");
            uiState.targetRegion = ui.item.parent().get(0);
            uiState.targetIndex = ui.item.index();
            rave.api.rpc.moveWidget(uiState);
            clearState();
        }

        function dragOver(event, ui) {
            adjustRowRegionsHeights();
        }

        // dynamically adjust heights of all regions
        function adjustRowRegionsHeights() {
            // handle region areas for upper rows
            if ($(".upperRow").length) {
                var rows = $(".regions").find(".upperRow");
                rows.each(adjustUpperRowRegionsHeight);
            }

            // handle region areas for the bottom row
            if ($(".bottomRow").length) {
                var row = $(".regions").find(".bottomRow");
                adjustBottomRowRegionsHeight(row)
            }
        }

        // adjusts the padding-bottom value of all regions in bottom row to either fill the empty space or
        // act as an upper row
        function adjustBottomRowRegionsHeight(row) {
            resetRowsRegionsHeight(row);
            var bodyHeight = $('body').outerHeight();
            var windowHeight = $(window).height();
            // Instances where no scroll bar currently exists
            if (windowHeight >= bodyHeight) {
                var pageHeight = $("#pageContent").outerHeight();
                var headerHeight = bodyHeight - pageHeight;
                var upperRegionsMaxHeights = 0;
                if ($(".upperRow").length) {
                    var rows = $(".regions").find(".upperRow");
                    for (var x = 0; x < rows.length; x++) {
                        var rowMaxHeight = getRowRegionsMaxHeight(rows.get(x));
                        upperRegionsMaxHeights = upperRegionsMaxHeights + rowMaxHeight;
                    }
                }
                // determine maximum size possible for bottom region
                // 50 px of buffer also removed to prevent scroll-bar from appearing in any cases
                var bottomPadding = (windowHeight - 50) - (upperRegionsMaxHeights + headerHeight);

                setRowsRegionsHeight(row, bottomPadding);
            }
            // Instances where scroll bar currently exists, can default to upper row behavior
            else {
                adjustUpperRowRegionsHeight(row);
            }
            // refresh sortables cached positions
            getNonLockedRegions().sortable("refreshPositions");
        }


        // adjusts the padding-bottom value of all regions in upper rows to match the value of the
        // tallest region in the row
        function adjustUpperRowRegionsHeight(row) {
            // when called by each, first argument is a number instead of a row value
            var row = (typeof row === 'number') ? $(this) : row;

            resetRowsRegionsHeight(row);

            // sets total region height to the height of tallest region
            setRowsRegionsHeight(row, getRowRegionsMaxHeight(row));

            // refresh sortables cached positions
            getNonLockedRegions().sortable("refreshPositions");
        }

        // Returns the height of the tallest region in row, minimum 100 px
        function getRowRegionsMaxHeight(row) {
            var rowChildren = $(row).children();
            var maxHeight = 100;
            for (var x = 0; x < rowChildren.length; x++) {
                if ($(rowChildren.get(x)).outerHeight() > maxHeight) {
                    maxHeight = $(rowChildren.get(x)).outerHeight();
                }
            }
            return maxHeight;
        }

        // Restores the padding-bottom value to the original for all regions in given row
        function resetRowsRegionsHeight(row) {
            // when called by each, first argument is a number instead of a row value
            var row = (typeof row === 'number') ? $(this) : row;

            var rowChildren = $(row).children();
            for (var x = 0; x < rowChildren.length; x++) {
                // reset to 5, the initial value before dragging
                $(rowChildren.get(x)).css("padding-bottom", 5);
            }
        }

        // Sets the padding-bottom value, so that the total height is the given value for all regions in given row
        function setRowsRegionsHeight(row, maxHeight) {
            var rowChildren = $(row).children();
            for (var x = 0; x < rowChildren.length; x++) {
                if ($(rowChildren.get(x)).outerHeight() != maxHeight) {
                    var defaultPadding = parseInt($(rowChildren.get(x)).css("padding-bottom").replace("px", ""));
                    $(rowChildren.get(x)).css("padding-bottom", (defaultPadding + maxHeight - $(rowChildren.get(x)).outerHeight()));
                }
            }
        }

        function clearState() {
            uiState.currentRegion = null;
            uiState.targetRegion = null;
            uiState.targetIndex = null;
            uiState.widget = null;
        }

        /**
         * Takes care of the UI part of the widget rendering. Depends heavily on the HTML structure
         */
        function initWidgetUI() {
            $(".widget-wrapper").each(function () {
                var widgetId = extractObjectIdFromElementId($(this).attr("id"));
                styleWidgetButtons(widgetId);
            });
        }

        function initMobileWidgetUI() {
            $(".widget-wrapper").each(function () {
                var widgetId = extractObjectIdFromElementId($(this).attr("id"));
                var widget = rave.getRegionWidgetById(widgetId);

                // init the collapse/restore toggle for the title bar
                $(this).find(".widget-title-bar-mobile").click({id:widgetId}, toggleCollapseAction);
            });
        }

        function toggleMobileWidget(regionWidgetId) {
            var args = {};
            args.data = {};
            args.data.id = regionWidgetId;
            toggleCollapseAction(args);
        }

        function maximizeAction(args, view_params) {
            var regionWidgetId = args.data.id;
            // display the widget in maximized view
            openFullScreenOverlay(regionWidgetId);
            var widget = rave.getRegionWidgetById(regionWidgetId);
            if (typeof widget != "undefined" && isFunction(widget.maximize)) {
                widget.maximize(view_params);
            }
        }

        function minimizeAction(args, view_params) {
            var regionWidgetId = args.data.id;
            $(".dnd-overlay").remove();
            getNonLockedRegions().sortable("option", "disabled", false);
            // display the widget in normal view
            $("#widget-" + regionWidgetId + "-wrapper").removeClass("widget-wrapper-canvas").addClass("widget-wrapper");
            // hide the widget minimize button
            $("#widget-" + regionWidgetId + "-min").hide();
            // show the widget menu
            $("#widget-" + regionWidgetId + "-widget-menu-wrapper").show();
            // show the collapse/restore toggle icon
            $("#widget-" + regionWidgetId + "-collapse").show();
            var widget = rave.getRegionWidgetById(regionWidgetId);
            // if the widget is collapsed execute the collapse function
            // otherwise execute the minimize function
            if (typeof widget != "undefined") {
                if (widget.collapsed && isFunction(widget.collapse)) {
                    widget.collapse();
                } else if (isFunction(widget.minimize)) {
                    widget.minimize(view_params);
                }
            }
        }

        function createPopup(popupType) {
            var target = POPUPS[popupType.toLowerCase()];

            if (!target) {
                return rave.log('The popup view requested is not implemented by rave');
            }

            if (target.singleton && $(target.containerSelector).length > 0) {
                return $(target.contentSelector).get(0);
            }

            var container = $(target.markup);
            $("#pageContent").prepend(container);

            if ($.type(target.initialize) == 'function') target.initialize(container);

            return container.find(target.contentSelector).get(0);
        }

        function destroyPopup(element) {
            element = $(element);
            var target = POPUPS[element.data('popupType')];

            if (!target) {
                rave.log('Rave has detected a destroy request for a popup whose type cannot be detected.');
                return element.detach();
            }

            if ($.type(target.cleanup) == 'function') target.cleanup(element);
        }

        function editCustomPrefsAction(args) {
            var regionWidgetId = args.data.id;

            // display the custom edit prefs for the widget in maximized view
            openFullScreenOverlay(regionWidgetId);
            var widget = rave.getRegionWidgetById(regionWidgetId);
            if (typeof widget != "undefined") {
                widget.editCustomPrefs();
            }
        }

        function toggleCollapseAction(args) {
            var regionWidgetId = args.data.id;
            var widget = getRegionWidgetById(regionWidgetId);
            // toggle the collapse state of the widget
            var newCollapsedValue = !widget.collapsed;
            var functionArgs = {"regionWidgetId":regionWidgetId, "collapsed":newCollapsedValue};

            // if this type of widget has a collapse or restore callback invoke it upon
            // successful persistence
            if (typeof widget != "undefined") {
                // if this is a collapse action, and the widget has a collapse implementation function,
                // attach it as a callback function
                if (newCollapsedValue && isFunction(widget.collapse)) {
                    functionArgs.successCallback = widget.collapse;
                }
                // if this is a restore action, and the widget has a restore implementation function,
                // attach it as a callback function
                else if (!newCollapsedValue && isFunction(widget.restore)) {
                    functionArgs.successCallback = widget.restore;
                }
            }

            // don't persist the collapse / restore state if we are in
            // mobile mode because we defaulted all widgets to collapsed
            // when initially rendering the mobile view
            if (rave.isMobile()) {
                rave.doWidgetUiCollapse(functionArgs);
            } else {
                rave.api.rest.saveWidgetCollapsedState(functionArgs);
            }
        }

        function doWidgetUiCollapse(args) {
            // update the in-memory widget with the new collapsed status
            rave.getRegionWidgetById(args.regionWidgetId).collapsed = args.collapsed;

            // toggle the collapse/restore icon
            rave.toggleCollapseWidgetIcon(args.regionWidgetId, args.collapsed);

            // if the widget has supplied a collapse or restore
            // function, invoke it so each widget provider
            // can handle the collapse / restore action independently
            if (typeof args.successCallback == 'function') {
                args.successCallback();
            }
        }

        /**
         * Utility function to generate the html label for a userPref
         * based on if it is required or not
         */
        function generatePrefLabelMarkup(userPref) {
            var markup = [];
            var prefLabel = (userPref.required) ? "* " + userPref.displayName : userPref.displayName;
            markup.push("<td class='");
            markup.push(WIDGET_PREFS_LABEL_CLASS);
            if (userPref.required) {
                markup.push(" ");
                markup.push(WIDGET_PREFS_LABEL_REQUIRED_CLASS);
            }
            markup.push("'>");
            markup.push(prefLabel);
            markup.push("</td>");
            return markup.join("");
        }

        /**
         * Utility function to generate the css class(es) of a userPref input
         * field based on if it is required or not
         */
        function generatePrefInputClassMarkup(userPref) {
            var markup = [];
            markup.push(WIDGET_PREFS_INPUT_CLASS);
            if (userPref.required) {
                markup.push(" ");
                markup.push(WIDGET_PREFS_INPUT_REQUIRED_CLASS);
            }
            return markup.join("");
        }

        /**
         * Utility function to validate a userPref input element
         */
        function validatePrefInput(element) {
            var isValid = true;
            var jqEl = $(element);
            // if the input is required verify it's trimmed input length is > 0
            if (jqEl.hasClass(WIDGET_PREFS_INPUT_REQUIRED_CLASS)) {
                isValid = $.trim(jqEl.val()).length > 0;
            }

            return isValid;
        }

        function editPrefsAction(regionWidgetId) {
            var regionWidget = getRegionWidgetById(regionWidgetId);
            var userPrefs = regionWidget.metadata.userPrefs;
            var hasRequiredUserPrefs = false;

            var prefsFormMarkup = [];
            prefsFormMarkup.push("<table>");

            for (var prefName in userPrefs) {
                var userPref = userPrefs[prefName];
                var currentPrefValue = regionWidget.userPrefs[userPref.name];
                var prefLabelMarkup = generatePrefLabelMarkup(userPref);
                var prefInputClassMarkup = generatePrefInputClassMarkup(userPref);
                if (userPref.required) {
                    hasRequiredUserPrefs = true;
                }

                switch (userPref.dataType) {
                    case "STRING":
                        prefsFormMarkup.push(TEXT_FIELD_TEMPLATE.replace(PREF_LABEL_TEMPLATE_REGEX, prefLabelMarkup)
                            .replace(CLASS_REGEX, prefInputClassMarkup)
                            .replace(NAME_REGEX, userPref.name)
                            .replace(VALUE_REGEX, typeof currentPrefValue != "undefined" ? currentPrefValue :
                            userPref.defaultValue));
                        break;
                    case "BOOL":
                        var checked = typeof currentPrefValue != "undefined" ?
                            currentPrefValue === 'true' || currentPrefValue === true :
                            userPref.defaultValue === 'true' || userPref.defaultValue === true;

                        prefsFormMarkup.push(CHECKBOX_TEMPLATE.replace(PREF_LABEL_TEMPLATE_REGEX, prefLabelMarkup)
                            .replace(CLASS_REGEX, prefInputClassMarkup)
                            .replace(NAME_REGEX, userPref.name)
                            .replace(CHECKED_REGEX, checked ? "checked" : ""));
                        break;
                    case "ENUM":
                        var options = [];

                        for (var i = 0; i < userPref.orderedEnumValues.length; i++) {
                            var option = userPref.orderedEnumValues[i];
                            var selected = currentPrefValue == option.value || (typeof currentPrefValue == "undefined" &&
                                option.value == userPref.defaultValue);
                            options.push(SELECT_OPTION_TEMPLATE.replace(VALUE_REGEX, option.value)
                                .replace(DISPLAY_VALUE_REGEX, option.displayValue)
                                .replace(SELECTED_REGEX, selected ? "selected" : ""));
                        }

                        prefsFormMarkup.push(SELECT_FIELD_TEMPLATE.replace(PREF_LABEL_TEMPLATE_REGEX, prefLabelMarkup)
                            .replace(CLASS_REGEX, prefInputClassMarkup)
                            .replace(NAME_REGEX, userPref.name)
                            .replace(OPTIONS_REGEX, options.join("")));
                        break;
                    case "LIST":
                        var values = typeof currentPrefValue != "undefined" ? currentPrefValue : userPref.defaultValue;
                        values = values.replace(PIPE_REGEX, "\n");
                        prefsFormMarkup.push(TEXTAREA_TEMPLATE.replace(PREF_LABEL_TEMPLATE_REGEX, prefLabelMarkup)
                            .replace(CLASS_REGEX, prefInputClassMarkup)
                            .replace(NAME_REGEX, userPref.name)
                            .replace(VALUE_REGEX, values));
                        break;
                    default:
                        prefsFormMarkup.push(HIDDEN_FIELD_TEMPLATE.replace(NAME_REGEX, userPref.name)
                            .replace(VALUE_REGEX, typeof currentPrefValue != "undefined" ? currentPrefValue :
                            userPref.defaultValue));
                }
            }

            // if this widget has one or more required inputs display the helper message
            if (hasRequiredUserPrefs) {
                prefsFormMarkup.push("<tr><td colspan='2' class='widget-prefs-required-text'>" + rave.getClientMessage("widget.prefs.required.title") + "</td></tr>");
            }

            prefsFormMarkup.push("<tr><td colspan='2'>");
            prefsFormMarkup.push(PREFS_SAVE_BUTTON_TEMPLATE.replace(ELEMENT_ID_REGEX, WIDGET_PREFS_SAVE_BUTTON(regionWidget.regionWidgetId))
                .replace(BUTTON_TEXT_REGEX, rave.getClientMessage("common.save")));
            prefsFormMarkup.push(PREFS_CANCEL_BUTTON_TEMPLATE.replace(ELEMENT_ID_REGEX, WIDGET_PREFS_CANCEL_BUTTON(regionWidget.regionWidgetId))
                .replace(BUTTON_TEXT_REGEX, rave.getClientMessage("common.cancel")));
            prefsFormMarkup.push("</td></tr>");
            prefsFormMarkup.push("</table>");

            var prefsElement = $("#" + WIDGET_PREFS_CONTENT(regionWidget.regionWidgetId));
            prefsElement.html(prefsFormMarkup.join(""));

            $("#" + WIDGET_PREFS_SAVE_BUTTON(regionWidget.regionWidgetId)).click({id:regionWidget.regionWidgetId},
                saveEditPrefsAction);
            $("#" + WIDGET_PREFS_CANCEL_BUTTON(regionWidget.regionWidgetId)).click({id:regionWidget.regionWidgetId},
                cancelEditPrefsAction);

            prefsElement.show();
        }

        function saveEditPrefsAction(args) {
            var regionWidget = getRegionWidgetById(args.data.id);
            var prefsElement = $("#" + WIDGET_PREFS_CONTENT(regionWidget.regionWidgetId));

            var updatedPrefs = {};
            var hasValidationErrors = false;
            // note that validation of "required" prefs is only done for text and
            // textarea types, since those represent STRING and LIST inputs, and
            // are the only inputs that could potentially contain empty data
            prefsElement.find("*").filter(":input").each(function (index, element) {
                switch (element.type) {
                    case "text":
                        if (!validatePrefInput(element)) {
                            hasValidationErrors = true;
                            $(element).addClass(WIDGET_PREFS_INPUT_FAILED_VALIDATION);
                        } else {
                            updatedPrefs[element.name] = $(element).val();
                            $(element).removeClass(WIDGET_PREFS_INPUT_FAILED_VALIDATION);
                        }
                        break;
                    case "select-one":
                    case "hidden":
                        updatedPrefs[element.name] = $(element).val();
                        break;
                    case "checkbox":
                        updatedPrefs[element.name] = $(element).is(':checked').toString();
                        break;
                    case "textarea":
                        if (!validatePrefInput(element)) {
                            hasValidationErrors = true;
                            $(element).addClass(WIDGET_PREFS_INPUT_FAILED_VALIDATION);
                        } else {
                            var valuesToPersist = [];
                            var textareaValues = $(element).val().split("\n");
                            for (var i = 0; i < textareaValues.length; i++) {
                                var value = $.trim(textareaValues[i]);
                                if (value.length > 0) {
                                    valuesToPersist.push(value);
                                }
                            }
                            updatedPrefs[element.name] = valuesToPersist.join("|");
                            $(element).removeClass(WIDGET_PREFS_INPUT_FAILED_VALIDATION);
                        }
                        break;
                }
            });

            // check to see if one or more input prefs had validation errors
            if (hasValidationErrors) {
                // focus on the first input that has validation errors
                prefsElement.find("." + WIDGET_PREFS_INPUT_FAILED_VALIDATION).first().focus();
            } else {
                if (isFunction(regionWidget.savePreferences)) {
                    regionWidget.savePreferences(updatedPrefs);
                }

                prefsElement.html("");
                prefsElement.hide();
            }
        }

        function cancelEditPrefsAction(args) {
            var prefsElement = $("#" + WIDGET_PREFS_CONTENT(args.data.id));
            prefsElement.html("");
            prefsElement.hide();
        }

        function addOverlay(jqElm) {
            var overlay = $('<div></div>');
            var styleMap = {
                position:"absolute",
                height:jqElm.height(),
                width:jqElm.width(),
                'z-index':10,
                opacity:0.7,
                background:"#FFFFFF"
            };

            // style it and give it the marker class
            $(overlay).css(styleMap);
            $(overlay).addClass("dnd-overlay");
            // add it to the dom before the iframe so it covers it
            jqElm.prepend(overlay[0]);
        }

        function openFullScreenOverlay(regionWidgetId) {
            addOverlay($("#pageContent"));
            getNonLockedRegions().sortable("option", "disabled", true);
            $("#widget-" + regionWidgetId + "-wrapper").removeClass("widget-wrapper").addClass("widget-wrapper-canvas");
            // hide the widget menu
            $("#widget-" + regionWidgetId + "-widget-menu-wrapper").hide();
            // display the widget minimize button
            $("#widget-" + regionWidgetId + "-min").show();
            // hide the collapse/restore toggle icon in canvas mode
            $("#widget-" + regionWidgetId + "-collapse").hide();
        }

        /**
         * Applies styling to the several buttons in the widget toolbar
         * @param widgetId identifier of the region widget
         */
        function styleWidgetButtons(widgetId) {
            var widget = rave.getRegionWidgetById(widgetId);

            // init the widget minimize button which is hidden by default
            // and only renders when widget is in maximized view
            $("#widget-" + widgetId + "-min").click({id:widgetId}, rave.minimizeWidget);

            // init the collapse/restore toggle
            // conditionally style the icon and setup the event handlers
            var $toggleCollapseIcon = $("#widget-" + widgetId + "-collapse");
            $toggleCollapseIcon.html((widget.collapsed) ? WIDGET_TOGGLE_DISPLAY_COLLAPSED_HTML : WIDGET_TOGGLE_DISPLAY_NORMAL_HTML);
            $toggleCollapseIcon
                .click({id:widgetId}, toggleCollapseAction)
                .mousedown(function (event) {
                    // don't allow drag and drop when this item is clicked
                    event.stopPropagation();
                });


            $('#widget-' + widgetId + '-toolbar').mousedown(function (event) {
                // don't allow drag and drop when this item is clicked
                event.stopPropagation();
            });
        }

        /**
         * Toggles the display of the widget collapse/restore icon.
         * @param widgetId the widgetId of the rendered widget to toggle the icon for
         */
        function toggleCollapseWidgetIcon(widgetId, collapsed) {
            var $toggleIcon = $("#widget-" + widgetId + "-collapse");
            if (collapsed) {
                $toggleIcon.html(WIDGET_TOGGLE_DISPLAY_COLLAPSED_HTML);
            } else {
                $toggleIcon.html(WIDGET_TOGGLE_DISPLAY_NORMAL_HTML);
            }
        }

        /**
         * Displays the "empty page" message on the page
         */
        function displayEmptyPageMessage() {
            $("#emptyPageMessageWrapper").removeClass("hidden");
        }

        function displayUsersOfWidget(widgetId) {
            rave.api.rest.getUsersForWidget({widgetId:widgetId, successCallback:function (data) {
                var html = "<ul class='widget-users'>";
                for (var i = 0; i < data.length; i++) {
                    var person = data[i];
                    var name = (person.displayName) ? person.displayName :
                        ((person.preferredName) ? person.preferredName : person.givenName) + " " + person.familyName;

                    html += "<li class='widget-user'>" + name + "</li>";
                }
                html += "</ul>";

                $("<div class='dialog widget-users-dialog' title='" + $("#widget-" + widgetId + "-title").text().trim() + " " + rave.getClientMessage("widget.users.added_by") + "'>" + html + "</div>").dialog({
                    modal:true,
                    buttons:[
                        {text:"Close", click:function () {
                            $(this).dialog("close");
                        }}
                    ]
                });
            }});
        }

        function showInfoMessage(message) {
            $("<div />", {'class':'alert alert-success navbar-spacer', 'text':message})
                .hide()
                .prependTo("body")
                .slideDown('fast').delay(5000)
                .slideUp(function () {
                    $(this).remove();
                });
        }

        function getNonLockedRegions() {
            return $(".region:not(.region-locked)");
        }

        return {
            init:init,
            initMobile:initMobileWidgetUI,
            toggleCollapseWidgetIcon:toggleCollapseWidgetIcon,
            maximizeAction:maximizeAction,
            minimizeAction:minimizeAction,
            createPopup:createPopup,
            destroyPopup:destroyPopup,
            editPrefsAction:editPrefsAction,
            editCustomPrefsAction:editCustomPrefsAction,
            setMobileState:setMobileState,
            getMobileState:getMobileState,
            doWidgetUiCollapse:doWidgetUiCollapse,
            toggleMobileWidget:toggleMobileWidget,
            displayEmptyPageMessage:displayEmptyPageMessage,
            displayUsersOfWidget:displayUsersOfWidget,
            showInfoMessage:showInfoMessage
        };

    })();

    function getClientMessage(key) {
        return clientMessages[key];
    }

    function addClientMessage(key, message) {
        return clientMessages[key] = message;
    }

    function registerWidget(regionId, widget) {
        if (!widgetsByRegionIdMap.hasOwnProperty(regionId)) {
            widgetsByRegionIdMap[regionId] = [];
        }
        widgetsByRegionIdMap[regionId].push(widget);
    }

    function getWidgetsByRegionIdMap() {
        return widgetsByRegionIdMap;
    }

    function clearWidgetsByRegionIdMap() {
        widgetsByRegionIdMap = {};
    }

    function initializeProviders() {
        //Current providers are rave.wookie and rave.opensocial.
        //Providers register themselves when loaded, so
        //JavaScript library importing order is important.
        //See page.jsp for example.
        for (var key in providerMap) {
            providerMap[key].init();
        }
    }

    function createNewOpenAjaxHub() {
        if (typeof OpenAjax == "undefined") {
            throw "No implementation of OpenAjax found.  " +
                "Please ensure that an implementation has been included in the page.";
        }
        return new OpenAjax.hub.ManagedHub({
            onSubscribe:function (topic, container) {
                log(container.getClientID() + " subscribes to this topic '" + topic + "'");
                return true;
            },
            onUnsubscribe:function (topic, container) {
                log(container.getClientID() + " unsubscribes from this topic '" + topic + "'");
                return true;
            },
            onPublish:function (topic, data, pcont, scont) {
                log(pcont.getClientID() + " publishes '" + data + "' to topic '" + topic + "' subscribed by " + scont.getClientID());
                return true;
            }
        });
    }

    function getOpenAjaxHubInstance() {
        if (typeof openAjaxHub == "undefined" || openAjaxHub == null) {
            openAjaxHub = createNewOpenAjaxHub();
        }
        return openAjaxHub;
    }

    function resetOpenAjaxHubInstance() {
        openAjaxHub = null;
    }

    function initializeWidgets() {
        //We get the widget objects in a map keyed by region ID.  The code below converts that map into a flat array
        //of widgets with all the top widgets in each region first, then the seconds widgets in each region, then the
        //third, etc until we have all widgets in the array.  This allows us to render widgets from left to right and
        //top to bottom to give the best user experience possible (rendering the top widgets first).
        //Note that this strategy relies on the javascript implementation to enumerate object properties in order:
        //http://stackoverflow.com/questions/280713/elements-order-in-a-for-in-loop
        //However this should at least get us to render the top "row" first, then the second "row", ... in any browser.
        //If this turns out to be a major concern we can change the widgetsByRegionIdMap to a 2D array instead of a map.
        var widgets = [];
        var regionWidget;
        for (var i = 0; ; i++) {
            var foundGadgets = false;
            for (var regionWidgets in widgetsByRegionIdMap) {
                regionWidgets = widgetsByRegionIdMap[regionWidgets];
                if (regionWidgets.length > i) {
                    foundGadgets = true;
                    regionWidget = regionWidgets[i];
                    // if client is viewing in mobile mode
                    // default to collapsed state
                    if (rave.isMobile()) {
                        regionWidget.collapsed = true;
                    }
                    widgets.push(regionWidget);
                }
            }

            if (!foundGadgets) {
                break;
            }
        }

        if (widgets.length == 0) {
            rave.displayEmptyPageMessage();
        } else {
            //Initialize the widgets for supported providers
            for (var j = 0; j < widgets.length; j++) {
                var widget = widgets[j];
                initializeWidget(widget);
                widgetByIdMap[widget.regionWidgetId] = widget;
            }
        }
    }

    function initializeWidget(widget) {
        if (widget.type == "DISABLED") {
            renderDisabledWidget(widget.regionWidgetId, unescape(widget.disabledMessage));
            return;
        }
        var provider = providerMap[widget.type];
        if (typeof provider == "undefined") {
            renderErrorWidget(widget.regionWidgetId, rave.getClientMessage("widget.provider.error"));
        } else {
            provider.initWidget(widget);
        }
    }

    function addProviderToList(provider) {
        if (provider.hasOwnProperty("init")) {
            providerMap[provider.TYPE] = provider;
        } else {
            throw "Attempted to register invalid provider";
        }
    }

    function extractObjectIdFromElementId(elementId) {
        var tokens = elementId.split("-");
        return tokens.length > 2 && tokens[0] == "widget" || tokens[0] == "region" ? tokens[1] : null;
    }

    function renderErrorWidget(id, message) {
        $("#widget-" + id + "-body").html(message);
    }

    function renderDisabledWidget(id, message) {
        $("#widget-" + id + "-body").html(message);
    }

    function updateContext(contextPath) {
        context = contextPath;
    }

    function getContext() {
        return context;
    }

    function getRegionWidgetById(regionWidgetId) {
        return widgetByIdMap[regionWidgetId];
    }

    function viewPage(pageId) {
        var fragment = (pageId != null) ? ("/" + pageId) : "";
        window.location.href = rave.getContext() + "page/view" + fragment;
    }

    function viewWidgetDetail(widgetId, referringPageId) {
        window.location.href = rave.getContext() + "store/widget/" + widgetId + "?referringPageId=" + referringPageId;
    }

    /**
     * Utility function to determine if a javascript object is a function
     * @param obj the object to check
     * @return true if object is a function, false otherwise
     */
    function isFunction(obj) {
        return (typeof obj == "function");
    }

    /**
     * Determines if a page is empty (has zero widgets)
     */
    function isPageEmpty() {
        return $.isEmptyObject(widgetByIdMap);
    }

    /**
     * Removes a regionWidgetId from the internal widget map
     * @param regionWidgetId the region widget id to remove
     */
    function removeWidgetFromMap(regionWidgetId) {
        delete widgetByIdMap[regionWidgetId];
    }

    /**
     * Logs to a console object if it exists
     * @param message the message to log
     */
    function log(message) {
        if (typeof console != "undefined" && console.log) {
            console.log(message);
        }
    }

    /**
     * Public API
     */
    return {
        /**
         * Registers the specified widget into the widgetsByRegionIdMap under the specified regionId.
         * @param regionId The regionId.
         * @param widget The widget.
         */
        registerWidget:registerWidget,

        /**
         * Initialize all of the registered providers
         */
        initProviders:initializeProviders,

        /**
         * Initializes the given set of widgets
         * @param widgets a map of widgets by regionId
         *
         * NOTE: widget object must have at a minimum the following properties:
         *      type,
         *      regionWidgetId
         */
        initWidgets:initializeWidgets,

        /**
         * Initialize Rave's drag and drop facilities
         */
        initUI:ui.init,

        /**
         * Initialize the mobile UI
         */
        initMobileUI:ui.initMobile,

        /**
         * Parses the given string conforming to a rave object's DOM element ID and return
         * the RegionWidget id
         *
         * NOTE: assumes convention of widget-RegionWidgetId-body|title|chrome|etc
         *       Supported rave objects:
         *          Region
         *          RegionWidget
         *
         * @param elementId the ID of the DOM element containing the widget
         */
        getObjectIdFromDomId:extractObjectIdFromElementId,

        /**
         * Registers a new provider with Rave.  All providers MUST have init and initWidget functions as well as a
         * TYPE property exposed in its public API
         *
         * @param provider a valid Rave widget provider
         */
        registerProvider:addProviderToList,

        /**
         * Renders an error in place of the widget
         *
         * @param id the RegionWidgetId of the widget to render in error mode
         * @param message The message to display to the user
         */
        errorWidget:renderErrorWidget,

        /**
         * Sets the context path for the Rave web application
         *
         * @param contextPath the context path of the rave webapp
         */
        setContext:updateContext,

        /**
         * Gets the current context
         */
        getContext:getContext,

        /**
         * Gets a regionwidget by region widget id
         */
        getRegionWidgetById:getRegionWidgetById,

        /**
         * View a page
         *
         * @param pageId the pageId to view, or if null, the user's default page
         */
        viewPage:viewPage,

        /**
         * View the widget detail page of a widget
         *
         * @param widgetId to widgetId to view
         * @param referringPageId the entityId of the page the call is coming from
         */
        viewWidgetDetail:viewWidgetDetail,

        /**
         * Toggles the collapse/restore icon of the rendered widget
         *
         * @param widgetId the widgetId of the rendered widget to toggle
         */
        toggleCollapseWidgetIcon:ui.toggleCollapseWidgetIcon,

        /***
         * Utility function to determine if a javascript object is a function or not
         *
         * @param obj the object to check
         * @return true if obj is a function, false otherwise
         */
        isFunction:isFunction,

        /***
         * Maximize the widget view
         *
         * @param args the argument object
         */
        maximizeWidget:ui.maximizeAction,

        /***
         * Minimize the widget view (render in non full-screen mode)
         *
         * @param args the argument object
         */
        minimizeWidget:ui.minimizeAction,

        /***
         * Create a new popup in the rave container
         *
         * @param popupType the type of popup that will be created
         * @return the new dom element created
         */
        createPopup:ui.createPopup,

        /***
         * Destroy a popup currently active in the rave container
         *
         * @param element the popup dom element
         */
        destroyPopup:ui.destroyPopup,

        /***
         * Display the inline edit prefs section for widget preferences inside
         * the widget.
         *
         * @param regionWidgetId the regionWidgetId of the widget
         *
         */
        editPrefs:ui.editPrefsAction,

        /***
         * "Preferences" view
         *
         * @param args the argument object
         */
        editCustomPrefs:ui.editCustomPrefsAction,

        /***
         * Get the mobile state - used by the UI to render mobile or normal content
         *
         */
        isMobile:ui.getMobileState,

        /***
         * Set the mobile state - used by the UI to render mobile or normal content
         *
         * @param mobileState boolean to represent the mobile state
         *
         */
        setMobile:ui.setMobileState,

        /**
         * Performs the client side work of collapsing/restoring a widget
         * @param args
         */
        doWidgetUiCollapse:ui.doWidgetUiCollapse,

        /**
         * Toggles a mobile widget collapse/restore
         * @param args
         */
        toggleMobileWidget:ui.toggleMobileWidget,

        /**
         * Determines if a page is empty (has zero widgets)
         * @param widgetByIdMap the map of widgets on the page
         */
        isPageEmpty:isPageEmpty,

        /**
         * Removes a regionWidgetId from the internal widget map
         * @param regionWidgetId the region widget id to remove
         */
        removeWidgetFromMap:removeWidgetFromMap,

        /**
         * Displays the "empty page" message on the page
         */
        displayEmptyPageMessage:ui.displayEmptyPageMessage,

        /**
         * Displays the users of a supplied widgetId in a dialog box
         */
        displayUsersOfWidget:ui.displayUsersOfWidget,

        /**
         * Displays an info message at the top of the page.
         * @param message The message to display.
         */
        showInfoMessage:ui.showInfoMessage,

        /**
         * Returns a language specific message based on the supplied key
         *
         * @param key the key of the message
         */
        getClientMessage:getClientMessage,

        /**
         * Adds a message to the internal client message map
         *
         * @param key
         * @param message
         */
        addClientMessage:addClientMessage,

        /**
         * Gets the singleton Managed OpenAJAX 2.0 Hub
         */
        getManagedHub:getOpenAjaxHubInstance,

        /**
         * Resets the managed hub
         */
        resetManagedHub:resetOpenAjaxHubInstance,

        /**
         * Logs a message to a central logging facility (console by default)
         *
         * @param message the message to log
         */
        log:log,

        /**
         * Returns the widgetsByRegionIdMap
         */
        getWidgetsByRegionIdMap:getWidgetsByRegionIdMap,

        /**
         * Clears the widgetsByRegionIdMap.  Useful for testing.
         */
        clearWidgetsByRegionIdMap:clearWidgetsByRegionIdMap
    }
})();
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var rave = rave || {};
rave.admin = rave.admin || (function() {

    var adminUi = (function() {

        function datatableClick() {
            $('.datatable tr').bind('click', function() {
                var link = $(this).attr('data-detaillink');
                if (link != undefined && link != '') {
                    window.location = link;
                }
            });
        }

        function init() {
            datatableClick();
        }

        return {
            init:init
        }
    })();

    return {
        initAdminUi : adminUi.init
    }

})();

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var rave = rave || {};
/**
 * Namespace that provides client access to Rave server APIs.
 * Note required jquery libraries must be imported by the containing page.
 */
rave.api = rave.api || (function() {
    function handleError(jqXhr, status, error) {
        alert(rave.getClientMessage("api.error") + error);
    }

    var restApi = (function() {
        //Base path to RPC services
        var path = "api/rest/";

        function saveWidgetPreferences(args) {
            var preferencesData = {"preferences": []};
            for (var prefName in args.userPrefs) {
                preferencesData.preferences.push({"name":prefName, "value":args.userPrefs[prefName]});
            }

            $.ajax({
                type: 'PUT',
                url: rave.getContext() + path + "regionWidgets/" + args.regionWidgetId + "/preferences",
                data: JSON.stringify(preferencesData),
                contentType: 'application/json',
                dataType: 'json',
                success: function(result) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback();
                    }
                },
                error: handleError
            });
        }
        
        function saveWidgetPreference(args) {
            $.ajax({
                type: 'PUT',
                url: rave.getContext() + path + "regionWidgets/" + args.regionWidgetId + "/preferences/" + args.userPref.prefName,
                data: JSON.stringify({"name":args.userPref.prefName, "value": args.userPref.prefValue}),
                contentType: 'application/json',
                dataType: 'json',
                success: function(result) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback();
                    }
                },
                error: handleError
            });
        }
        
        function saveWidgetCollapsedState(args) {
            $.ajax({
                type: 'PUT',
                url: rave.getContext() + path + "regionWidgets/" + args.regionWidgetId + "/collapsed",
                data: JSON.stringify(args.collapsed),  
                contentType: 'application/json',
                dataType: 'json',
                success: function(result) {                    
                    rave.doWidgetUiCollapse({"regionWidgetId": result.entityId, 
                                             "collapsed": result.collapsed, 
                                             "successCallback": args.successCallback});                    
                },
                error: handleError
            });                        
        }
        
        function deletePage(args) {
            $.ajax({
                type: 'DELETE',
                url: rave.getContext() + path + "page/" + args.pageId,                              
                success: function(result) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback();
                    }
                },
                error: handleError
            });            
        }
        
        function deleteWidgetRating(args) {
            $.ajax({
                type: 'DELETE',
                url: rave.getContext() + path + "widgets/" + args.widgetId + "/rating",
                success: function(result) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback();
                    }
                },
                error: handleError
            })
        }
        
        function updateWidgetRating(args) {
            $.ajax({
                type: 'POST',
                url: rave.getContext() + path + "widgets/" + args.widgetId + "/rating?score=" + args.score,
                success: function(result) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback();
                    }
                },
                error: handleError
            })
        }
        
        function createWidgetComment(args) {
            $.ajax({
                type: 'POST',
                url: rave.getContext() + path + "widgets/" + args.widgetId + "/comments?text=" + escape(args.text),
                success: function(result) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback();
                    }
                },
                error: handleError
            })
        }
        
        function deleteWidgetComment(args) {
            $.ajax({
                type: 'DELETE',
                url: rave.getContext() + path + "widgets/" + args.widgetId + "/comments/" + args.commentId,
                success: function(result) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback();
                    }
                },
                error: handleError
            })
        }
        
        function updateWidgetComment(args) {
            $.ajax({
                type: 'POST',
                url: rave.getContext() + path + "widgets/" + args.widgetId + "/comments/" + args.commentId + "?text=" + escape(args.text),
                success: function(result) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback();
                    }
                },
                error: handleError
            })
        }

        function getUsersForWidget(args) {
            $.ajax({
                type: 'GET',
                url: rave.getContext() + path + "widgets/" + args.widgetId + "/users",
                success: function(result) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback(result);
                    }
                },
                error: handleError
            })
        }

        function createWidgetTag(args) {
            $.ajax({
                type:'POST',
                url:rave.getContext() + path + "widgets/" + args.widgetId + "/tags?tagText=" + escape(args.text),
                success:function (result) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback();
                    }
                },
                error:handleError
            })
        }

        function getTags(args) {
            $.ajax({
                type:'GET',
                url:rave.getContext() + path + "widgets/"+args.widgetId  + "/tags",
                dataType:"json",
                success:function (data) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback(data);
                    }
                }
            });


        }


        return {
            updateWidgetRating: updateWidgetRating,
            deleteWidgetRating: deleteWidgetRating,
            saveWidgetPreferences : saveWidgetPreferences,
            saveWidgetPreference : saveWidgetPreference,
            saveWidgetCollapsedState : saveWidgetCollapsedState,
            createWidgetComment : createWidgetComment,
            updateWidgetComment : updateWidgetComment,
            deleteWidgetComment : deleteWidgetComment,
            deletePage : deletePage,
            getUsersForWidget: getUsersForWidget,
            createWidgetTag: createWidgetTag,
            getTags: getTags
        };
    })();

    var rpcApi = (function() {
        //Base path to RPC services
        var path = "api/rpc/";

        //This method is implemented by PageApi.java.
        function moveWidgetOnPage(args) {
            var widgetObjectId = rave.getObjectIdFromDomId(args.widget.id);
            var toRegionObjectId = rave.getObjectIdFromDomId(args.targetRegion.id);
            var fromRegionObjectId = rave.getObjectIdFromDomId(args.currentRegion.id);
            //Note context must be set outside this library.  See page.jsp for example.
            $.post(rave.getContext() + path + "page/regionWidget/" + widgetObjectId + "/move",
                {
                    newPosition: args.targetIndex,
                    toRegion: toRegionObjectId,
                    fromRegion: fromRegionObjectId
                },
                function(result) {
                    if (result.error) {
                        handleRpcError(result);
                    }
                }
            ).error(handleError);
        }

        function addWidgetToPage(args) {
            $.post(rave.getContext() + path + "page/" + args.pageId + "/widget/add",
                {
                    widgetId: args.widgetId
                },
                function(result) {
                    if (result.error) {
                        handleRpcError(result);
                    } else {
                        var widgetTitle = rave.getClientMessage("widget.add_prefix");
                        var addedWidget = result.result != undefined ? result.result.widget : undefined;

                        if (addedWidget != undefined && addedWidget.title != undefined && addedWidget.title.length > 0) {
                            widgetTitle = addedWidget.title;
                        }
                        rave.showInfoMessage(widgetTitle + ' ' + rave.getClientMessage("widget.add_suffix"));
                    }
                }).error(handleError);
        }

        function deleteWidgetOnPage(args) {
            $.post(rave.getContext() + path + "page/regionWidget/" + args.regionWidgetId + "/delete",
                null,
                function(result) {
                    if (result.error) {
                        handleRpcError(result);
                    } else {
                        if (typeof args.successCallback == 'function') {
                            args.successCallback();
                        }
                    }
                }).error(handleError);
        }
        
        function addPage(args) {
            $.post(rave.getContext() + path + "page/add",
                {
                    pageName: args.pageName,
                    pageLayoutCode: args.pageLayoutCode
                },
                function(result) {
                    if (result.error) {
                        // check to see if a duplicate page name error occurred
                        if (result.errorCode == 'DUPLICATE_ITEM') {                        
                            $("#pageFormErrors").html(rave.getClientMessage("page.duplicate_name"));
                        } else {                        
                            handleRpcError(result);
                        }
                    } else {
                        if (typeof args.successCallback == 'function') {
                            args.successCallback(result);
                        }
                    }
                }).error(handleError);
        }
        
        function movePage(args) {
            // the moveAfterPageId attribute could be undefined if moving
            // to the first position. In that case don't send a moveAfterPageId
            // post parameter
            var data = {};
            if (args.moveAfterPageId) {
                data["moveAfterPageId"] = args.moveAfterPageId;
            }
            
            $.post(rave.getContext() + path + "page/" + args.pageId + "/move",
                data,
                function(result) {
                    if (result.error) {                   
                        handleRpcError(result);                        
                    } else {
                        if (typeof args.successCallback == 'function') {
                            args.successCallback(result);
                        }
                    }
                }).error(handleError);
        }

        function moveWidgetToPage(args) {
            var data = {};
            if (args.toPageId) {
                data["toPageId"] = args.toPageId;
                data["regionWidgetId"] = args.regionWidgetId;
            }

            $.post(rave.getContext() + path + "page/" + args.toPageId + "/moveWidget",
                data,
                function(result) {
                    if (result.error) {
                        handleRpcError(result);
                    } else {
                        if (typeof args.successCallback == 'function') {
                            args.successCallback(result);
                        }
                    }
                }).error(handleError);
        }

        function updatePagePrefs(args) {
            $.post(rave.getContext() + path + "page/" + args.pageId + "/update",
               {"name": args.title, "layout": args.layout},
               function(result) {
                   if (result.error) {
                       handleRpcError(result);
                   }
                   else {
                       if (typeof args.successCallback == 'function') {
                            args.successCallback(result);
                       }
                   }
               }).error(handleError);
        }

        function getPagePrefs(args) {
            $.get(rave.getContext() + path + "page/get?pageId="+args.pageId,
                  null,
                  function(result) {
                    if (typeof args.successCallback == 'function') {
                        args.successCallback(result);
                    }
                  }
            );
        }

        //TODO RAVE-228: Create a more robust error handling system and interrogation of RPC results
        function handleRpcError(rpcResult) {
            switch (rpcResult.errorCode) {
                case "NO_ERROR" :
                    break;
                case "INVALID_PARAMS":
                    alert(rave.getClientMessage("api.rpc.error.invalid_params"));
                    break;
                case "INTERNAL_ERROR":
                    alert(rave.getClientMessage("api.rpc.error.internal"));
                    break;                
            }
        }

        function getWidgetMetadata(args) {
            var url = args.url;
            var providerType = args.providerType;
            if ( url == null || providerType == null ) {
                alert(rave.getClientMessage("api.widget_metadata.invalid_params"));
                return;
            }
            $.post(rave.getContext() + path + "widget/metadata/get",
               {"url": url, "type": providerType},
               function(result) {
                   if (result.error) {
                       alert(rave.getClientMessage("api.widget_metadata.parse_error"));
                   }
                   else {
                       if (typeof args.successCallback == 'function') {
                            args.successCallback(result);
                       }
                   }
               }).error(handleError);
        }

        function getWidgetMetadataGroup(args) {
            var url = args.url;
            var providerType = args.providerType;
            if ( url == null || providerType == null ) {
                alert(rave.getClientMessage("api.widget_metadata.invalid_params"));
                return;
            }
            $.post(rave.getContext() + path + "widget/metadatagroup/get",
               {"url": url, "type": providerType},
               function(result) {
                   if (result.error) {
                       alert(rave.getClientMessage("api.widget_metadata.parse_error"));
                   }
                   else {
                       if (typeof args.successCallback == 'function') {
                            args.successCallback(result);
                       }
                   }
               }).error(handleError);
        }

        return {
            moveWidget : moveWidgetOnPage,
            addWidgetToPage : addWidgetToPage,
            removeWidget : deleteWidgetOnPage,
            addPage: addPage,
            updatePagePrefs: updatePagePrefs,
            getPagePrefs: getPagePrefs,
            movePage: movePage,
            moveWidgetToPage: moveWidgetToPage,
            getWidgetMetadata: getWidgetMetadata,
            getWidgetMetadataGroup: getWidgetMetadataGroup
        };

    })();

    /*
     *	Handler functions to handle modifications on user events 
     */
    var handlerApi = (function() {
    	
    	//function to handle widget rating changes
    	function widgetRatingHandler(widgetRating) {
    		
    		//retrieving the current total likes
    		var likeTotalLabel = document.getElementById("totalLikes-"+ widgetRating.widgetId);
    		var likeTotal = likeTotalLabel.getAttribute("data-rave-widget-likes"); 
    		
    		//retrieving the current total dislikes
    		var dislikeTotalLabel = document.getElementById("totalDislikes-"+ widgetRating.widgetId);
			var dislikeTotal = dislikeTotalLabel.getAttribute("data-rave-widget-dislikes"); 
    		
			//initializing temporary variables
			var incrementingTotal = -1;
			var decrementingTotal = -1;
			var curButton = "";
			var prevButton = "";
			var prevRating = -1;
			
			//check if like rating needs to be updated
    		if(widgetRating.isLike) {
    			
    			//set incrementing total to like total
    			incrementingTotal = likeTotal;
    			
    			//set the incrementing total label to like total label
    			incrementingTotalLabel = likeTotalLabel;
    			
    			//set decrementing total to dislike total
    			decrementingTotal = dislikeTotal;
    			
    			//set the decrementing total label to dislike total label
    			decrementingTotalLabel = dislikeTotalLabel;
    			
    			//set the current clicked button to like button
    			curButton = widgetRating.widgetLikeButton;
    			
    			//set the previous clicked button to dislike button
    			prevButton = widgetRating.widgetDislikeButton;
    			
    			//set the previous rating to 0 to check if dislike was clicked earlier 
    			prevRating = 0;
    		}
    		
    		//check if dislike rating needs to be updated
    		else {
    			    			
    			//set incrementing total to dislike total
    			incrementingTotal = dislikeTotal;
    			
    			//set the incrementing total label to dislike total label
    			incrementingTotalLabel = dislikeTotalLabel;
    			
    			//set decrementing total to like total
    			decrementingTotal = likeTotal;
    			
    			//set the decrementing total label to like total label
    			decrementingTotalLabel = likeTotalLabel;
    			
    			//set the current clicked button to dislike button
    			curButton = widgetRating.widgetDislikeButton;
    			
    			//set the previous clicked button to like button
    			prevButton = widgetRating.widgetLikeButton;
    			
    			//set the previous rating to 10 to check if like was clicked earlier 
    			prevRating = 10;
    		}
        		        		
    		//update incrementing total
        	incrementingTotal = parseInt(incrementingTotal) + 1;
        	if(incrementingTotalLabel == likeTotalLabel) {
        		incrementingTotalLabel.setAttribute("data-rave-widget-likes", incrementingTotal);
        		incrementingTotalLabel.innerHTML = incrementingTotal;
        	}
        	else {
        		incrementingTotalLabel.setAttribute("data-rave-widget-dislikes", incrementingTotal);
        		incrementingTotalLabel.innerHTML = incrementingTotal;
        	}
        	
        	//get the value of hidden user rating 
        	var hiddenButton = document.getElementById("rate-"+ widgetRating.widgetId);
        	var userPrevRate = hiddenButton.value;

        	//if the other button in this pair was checked then ajdust its total, except in IE where
        	//the button has already toggled BEFORE the 'change' event in which case we have to assume
        	//that the user had a contrary selection prior to the change event
        	if (prevButton.get(0).getAttribute("checked") == "true" || curButton.checked == true) {
        		prevButton.get(0).setAttribute("checked", "false");
			
        		//remove the previous rating made by the user if any by checking change in userRating
        		if(parseInt(userPrevRate) == prevRating) {
        			       				
        			//update decrementing total
        			if(parseInt(decrementingTotal) - 1 > -1) {
        				decrementingTotal = parseInt(decrementingTotal) - 1;
        				if(decrementingTotalLabel == likeTotalLabel) {
        					decrementingTotalLabel.setAttribute("data-rave-widget-likes", decrementingTotal);
        					decrementingTotalLabel.innerHTML = decrementingTotal;
        				}
        				else {
        					decrementingTotalLabel.setAttribute("data-rave-widget-dislikes", decrementingTotal);
        					decrementingTotalLabel.innerHTML = decrementingTotal;
        				}
        			}
        		}
            		
        	}
            
        	//flag this element as the currently checked one
        	curButton.setAttribute("checked", "true");

        	//set the user rating of the hidden field
        	if(widgetRating.isLike) {
        		hiddenButton.value = "10";
        	}
        	else{
        		hiddenButton.value = "0";
        	}
    	}

    	//function to toggle sliding down and up of user profile tabs
    	function userProfileTabHandler(profileTab) {
    			//parsing profile tab id to obtain panel id
    			var panelId = "#" + profileTab.id.substring(0, profileTab.id.indexOf("Tab")) + "Panel";
    			$(panelId).slideToggle("slow");
    	}
    	
    	//function to toggle hide and show of tag pages
    	function userProfileTagHandler(profileTag, defaultTagPage) {
    		
    			//first close any tag pages if open
    			$(".profile-tag-page").hide();
    			
    			//show default tag page is set true
    			if(defaultTagPage != null) {
    				$(defaultTagPage).show();
    			}
    			
    			else {
    				//extract the tag page id from profile tag id
    				var tagPageId = "#" + profileTag.id + "Page";
    				//show the requested tag page
    				$(tagPageId).show();
    			}
    	}
    	
    	function userProfileEditHandler(isEdit) {
    		//get the edit element
    		var profileInfo = document.getElementById("profileInfo");
    		//extract hidden fields through their class
    		var hiddenFields = "." + profileInfo.value + "-hidden";
    		//extract labels through their class
    		var visibleFields = "." + profileInfo.value + "-visible";
    		    		
    		if(isEdit) {
    			//make hidden fields visible
    			$(hiddenFields).show();
    			//make visible fields invisible
    			$(visibleFields).hide();
    		}
    		
    		else {
    			//make hidden fields invisible
    			$(hiddenFields).hide();
    			//make visible fields visible
    			$(visibleFields).show();
    		}
    	}
    	
    	return {
    		widgetRatingHandler : widgetRatingHandler,
    		userProfileTabHandler : userProfileTabHandler,
    		userProfileTagHandler : userProfileTagHandler,
    		userProfileEditHandler : userProfileEditHandler
    	};
    	
    })();

    return {
        rest : restApi,
        rpc : rpcApi,
        handler : handlerApi
    };
})();

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var rave = rave || {};
rave.forms = rave.forms || (function() {

    function validateNewAccountForm() {
        $("#newAccountForm").validate({
            rules: {
                username : {
                    required: true,
                    minlength: 2
                },
                password : {
                    required: true,
                    minlength: 4
                },
                confirmPassword : {
                    required: true,
                    minlength: 4,
                    equalTo: "#passwordField"
                },
                email : {
                    required: true
                }
            },
            messages: {
                confirmPassword: {
                    equalTo: rave.getClientMessage("form.password.invalid_match")
                }
            }
        });
    }

    function validateUserProfileForm() {
        $("#userProfileForm").validate({
            rules: {
                password : {
                    required: true,
                    minlength: 4
                },
                passwordConfirm : {
                    required: true,
                    minlength: 4,
                    equalTo: "#passwordField"
                }
            },
            messages: {
                passwordConfirm: {
                    equalTo: rave.getClientMessage("form.password.invalid_match")
                }
            }
        });
    }
    
    function validatePageForm() {
        $("#pageForm").validate({
            rules: {
                tab_title : {
                    required: true
                }
            }
        });
    }

    return {
        validateNewAccountForm : validateNewAccountForm,
	    validateUserProfileForm: validateUserProfileForm,
        validatePageForm: validatePageForm
    };
})();
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var rave = rave || {};
rave.layout = rave.layout || (function() {
    var MOVE_PAGE_DEFAULT_POSITION_IDX = -1;
    var $moveWidgetDialog;
    var $movePageDialog = $("#movePageDialog");
    var $pageForm = $("#pageForm");
    var $tab_title_input = $("#tab_title"),
        $tab_id = $("#tab_id"),
        $page_layout_input = $("#pageLayout");

    // page menu related functions
    var pageMenu = (function() {
        var $addPageButton = $("#addPageButton");
        var $menuItemEdit = $("#pageMenuEdit");
        var $menuItemDelete = $("#pageMenuDelete");
        var $menuItemMove = $("#pageMenuMove");

        /**
         * Initializes the private pageMenu closure
         * - binds click event handler to menu button
         * - binds menu item click event handlers
         * - binds body click event handler to close the menu
         */
        function init() {
            // initialize the page form validator overriding the
            // styles to wire in bootstrap styles
            $pageForm.validate({
                errorElement: 'span',
                errorClass: 'help-inline',
                highlight: function (element, errorClass) {
                    $(element).parent().parent().addClass('error');
                },
                unhighlight: function (element, errorClass) {
                    $(element).parent().parent().removeClass('error');
                }
            });

            // initialize the close button in the page menu dialog
            $("#pageMenuCloseButton").click(rave.layout.closePageDialog);

            // setup the edit page menu item
            $addPageButton.bind('click', function(event) {
                $("#pageMenuDialogHeader").html(rave.getClientMessage("page.add"));
                var $pageMenuUpdateButton = $("#pageMenuUpdateButton");
                $pageMenuUpdateButton.html(rave.getClientMessage("common.add"));
                // unbind the previous click event since we are sharing the
                // dialog between separate add/edit page actions
                $pageMenuUpdateButton.unbind('click');
                $pageMenuUpdateButton.click(rave.layout.addPage);
                $("#pageMenuDialog").modal('show');
            });

            // setup the edit page menu item
            $menuItemEdit.bind('click', function(event) {
                 rave.api.rpc.getPagePrefs({pageId: getCurrentPageId(),
                                        successCallback: function(result) {
                                            $tab_title_input.val(result.result.name);
                                            $tab_id.val(result.result.entityId);
                                            $page_layout_input.val(result.result.pageLayout.code);
                                            $("#pageMenuDialogHeader").html(rave.getClientMessage("page.update"));
                                            var $pageMenuUpdateButton = $("#pageMenuUpdateButton");
                                            $pageMenuUpdateButton.html(rave.getClientMessage("common.save"));
                                            // unbind the previous click event since we are sharing the
                                            // dialog between separate add/edit page actions
                                            $pageMenuUpdateButton.unbind('click');
                                            $pageMenuUpdateButton.click(rave.layout.updatePage);
                                            $("#pageMenuDialog").modal('show');
                                        }
                });
            });

            // setup the delete page menu item if it is not disabled
            if (!$menuItemDelete.hasClass("menu-item-disabled")) {
                $menuItemDelete.bind('click', function(event) {
                    // send the rpc request to delete the page
                    rave.api.rest.deletePage({pageId: getCurrentPageId(), successCallback: rave.viewPage});
                });
            }

            // setup the move page menu item if it is not disabled
            if (!$menuItemMove.hasClass("menu-item-disabled")) {
                $menuItemMove.bind('click', function(event) {
                    $movePageDialog.modal('show');
                });
            }
        }

        return {
            init: init
        }
    })();

    // widget menu related functions
    var widgetMenu = (function() {
        var $menu;
        var $menuItemMove;
        var $menuItemDelete;
        var $menuItemMaximize;

        /**
         * Hides the widget menu for a specific widget
         * @param widgetId the id of the widget to hide the menu for
         */
        function hideMenu(widgetId) {
            $("#widget-" + widgetId + "-menu").hide();
        }
        /**
         * Hides all widget menus
         */
        function hideAllMenus() {
            $(".widget-menu").hide();
        }
        /**
         * Shows the widget menu for a specific widget
         * @param widgetId the id of the widget to show the menu for
         */
        function showMenu(widgetId) {
            $("#widget-" + widgetId + "-menu").show();
        }

        /**
         * Initializes the private widgetMenu closure
         * - binds click event handler to menu button
         * - binds menu item click event handlers
         * - binds body click event handler to close the menu
         */
        function init() {
            // loop over each widget-menu and initialize the menu items
            // note: the edit prefs menu item is by default rendered disabled
            //       and it is up to the provider code for that widget to
            //       determine if the widget has preferences, and to enable
            //       the menu item
            $(".widget-menu").each(function(index, element){
                var widgetId = rave.getObjectIdFromDomId(element.id);

                // setup the move to page menu item
                $menuItemMove = $("#widget-" + widgetId + "-menu-move-item");
                if (!$menuItemMove.hasClass("menu-item-disabled")) {
                    $menuItemMove.bind('click', function(event) {
                        var regionWidgetId = rave.getObjectIdFromDomId(this.id);
                        // Clear the dropdown box; needing to do this may be a bug?
                        $('.dropdown').removeClass('open');
                        // Open the modal
                        $("#moveWidgetModal").data('regionWidgetId', regionWidgetId);
                        $("#moveWidgetModal").modal('show');

                        // prevent the menu button click event from bubbling up to parent
                        // DOM object event handlers such as the page tab click event
                        event.stopPropagation();
                    });
                }

                // setup the delete widget menu item
                $menuItemDelete  = $("#widget-" + widgetId + "-menu-delete-item");
                if (!$menuItemDelete.hasClass("menu-item-disabled")) {
                    $menuItemDelete.bind('click', function(event) {
                        var regionWidgetId = rave.getObjectIdFromDomId(this.id);

                        // invoke the rpc call to remove the widget from the page
                        rave.layout.deleteRegionWidget(regionWidgetId);

                        // prevent the menu button click event from bubbling up to parent
                        // DOM object event handlers such as the page tab click event
                        event.stopPropagation();
                    });
                }

                // setup the maximize widget menu item
                $menuItemMaximize  = $("#widget-" + widgetId + "-menu-maximize-item");
                if (!$menuItemMaximize.hasClass("menu-item-disabled")) {
                    $menuItemMaximize.bind('click', function(event) {
                        var regionWidgetId = rave.getObjectIdFromDomId(this.id);

                        // maximize the widget
                        rave.maximizeWidget({data: {id: regionWidgetId}});
                        // prevent the menu button click event from bubbling up to parent
                        // DOM object event handlers such as the page tab click event
                        event.stopPropagation();
                    });
                }

                // setup the about this widget menu item
                $menuItemAbout  = $("#widget-" + widgetId + "-menu-about-item");
                if (!$menuItemAbout.hasClass("menu-item-disabled")) {
                    $menuItemAbout.bind('click', function(event) {
                        var regionWidget = rave.getRegionWidgetById(rave.getObjectIdFromDomId(this.id));

                        // go to the widget detail page
                        rave.viewWidgetDetail(regionWidget.widgetId, getCurrentPageId());
                        // prevent the menu button click event from bubbling up to parent
                        // DOM object event handlers such as the page tab click event
                        event.stopPropagation();
                    });
                }
            });
        }

        /**
         * Enables the Edit Prefs including the Preferences view (Custom Edit Prefs)
         * menu item in the widget menu to be clicked.
         * Widget providers should use this function when initializing their
         * widgets after determining if the widget has preferences to modify.
         *
         * @param regionWidgetId the regionWidgetId of the regionWidget menu to enable
         * @param isPreferencesView boolean to indicate whether "preferences" view or the default prefs view
         */
        function enableEditPrefsMenuItem(regionWidgetId, isPreferencesView) {
            // setup the edit prefs widget menu item
            var $menuItemEditPrefs  = $("#widget-" + regionWidgetId + "-menu-editprefs-item");
            $menuItemEditPrefs.removeClass("menu-item-disabled");
            $menuItemEditPrefs.bind('click', function(event) {
                var regionWidgetId = rave.getObjectIdFromDomId(this.id);

                // show the regular edit prefs or the Custom Edit Prefs(preferences) region
                if ( isPreferencesView )
                    rave.editCustomPrefs({data: {id: regionWidgetId}});
                else
                    rave.editPrefs(regionWidgetId);
                // prevent the menu button click event from bubbling up to parent
                // DOM object event handlers such as the page tab click event
                event.stopPropagation();
            });
        }

        return {
            init: init,
            hideAll: hideAllMenus,
            hide: hideMenu,
            show: showMenu,
            enableEditPrefsMenuItem: enableEditPrefsMenuItem
        }
    })();

    /**
     * Submits the RPC call to move the widget to a new page
     */
    function moveWidgetToPage(regionWidgetId) {
        var toPageId = $("#moveToPageId").val();
        var args = { toPageId: toPageId,
                     regionWidgetId: regionWidgetId,
                     successCallback: function() { rave.viewPage(toPageId); }
                   };
        // send the rpc request to move the widget to new page
        rave.api.rpc.moveWidgetToPage(args);
    }

    /**
     * Submits the RPC call to add a new page if form validation passes
     */
    function addPage() {
        // if the form has passed validation submit the request
        if ($pageForm.valid()) {
            var newPageTitle = $tab_title_input.val();
            var newPageLayoutCode = $page_layout_input.val();

            // send the rpc request to create the new page
            rave.api.rpc.addPage({pageName: newPageTitle,
                                  pageLayoutCode: newPageLayoutCode,
                                  successCallback: function(result) {
                                      rave.viewPage(result.result.entityId);
                                  }
            });
        }
    }

    /**
     * Submits the RPC call to move the page to a new render sequence
     */
    function movePage() {
        var moveAfterPageId = $("#moveAfterPageId").val();
        var args = { pageId: $("#currentPageId").val(),
                     successCallback: function(result) { rave.viewPage(result.result.entityId); }
                   };

        if (moveAfterPageId != MOVE_PAGE_DEFAULT_POSITION_IDX) {
            args["moveAfterPageId"] = moveAfterPageId;
        }

        // send the rpc request to move the new page
        rave.api.rpc.movePage(args);
    }

    function updatePage() {
        if ($pageForm.valid()) {
            // send the rpc request to update the page
            rave.api.rpc.updatePagePrefs({pageId: $tab_id.val(),
                                            title: $tab_title_input.val(),
                                            layout: $page_layout_input.val(),
                                            successCallback: function(result) {
                                                rave.viewPage(result.result.entityId);
                                            }});
        }
    }

    function closePageDialog() {
        $pageForm[0].reset();
        $tab_id.val('');
        $("#pageMenuDialog").modal("hide");
    }

    /**
     * Invokes the RPC call to delete a regionWidget from a page
     *
     * @param regionWidgetId the regionWidgetId to delete
     */
    function deleteRegionWidget(regionWidgetId) {
        if (confirm(rave.getClientMessage("widget.remove_confirm"))) {
            rave.api.rpc.removeWidget({
                regionWidgetId: regionWidgetId,
                successCallback: function() {
                    // remove the widget from the dom and the internal memory map
                    $("#widget-" + this.regionWidgetId + "-wrapper").remove();
                    rave.removeWidgetFromMap(this.regionWidgetId);
                    if (rave.isPageEmpty()) {
                        rave.displayEmptyPageMessage();
                    }
                }
            });
        }
    }

    /**
     * Returns the pageId of the currently viewed page
     */
    function getCurrentPageId() {
        return $("#currentPageId").val();
    }

   /***
    * initializes the rave.layout namespace code
    */
    function init() {
        pageMenu.init();
        widgetMenu.init();
        // initialize the bootstrap dropdowns
        $(".dropdown-toggle").dropdown();
    }

    // public rave.layout API
    return {
        init: init,
        getCurrentPageId: getCurrentPageId,
        hideWidgetMenu: widgetMenu.hide,
        deleteRegionWidget: deleteRegionWidget,
        enableEditPrefsMenuItem: widgetMenu.enableEditPrefsMenuItem,
        addPage: addPage,
        updatePage: updatePage,
        movePage: movePage,
        closePageDialog: closePageDialog,
        moveWidgetToPage: moveWidgetToPage
    };
})();
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var rave = rave || {};
rave.opensocial = rave.opensocial || (function () {
    var WIDGET_TYPE = "OpenSocial";
    var OFFSET = 10;
    var MIN_HEIGHT = 250;
    var VIEW_NAMES = {
        CANVAS:"canvas",
        DEFAULT:"default",
        HOME:"home",
        PREFERENCES:"preferences"
    };
    var VIEW_TARGETS = {
        TAB: 'tab',
        DIALOG: 'dialog',
        MODALDIALOG: 'modal_dialog',
        SIDEBAR: 'sidebar'
    }

    var container;

    /**
     * Initialization
     */
    function initOpenSocial() {
        initContainer();
        registerRpcHooks();
        implementViews();
        gadgets.pubsub2router.init({
            hub:rave.getManagedHub()
        })
    }

    function initContainer() {
        //Create the common container instance.
        var containerConfig = {};
        containerConfig[osapi.container.ServiceConfig.API_PATH] = "/rpc";
        containerConfig[osapi.container.ContainerConfig.RENDER_DEBUG] = "1";
        container = new osapi.container.Container(containerConfig);
    }

    /**
     * Gets the container singleton or initializes if not instantiated
     */
    function getContainer() {
        if (typeof container == "undefined" || container == null) {
            initContainer();
        }
        return container;
    }

    /** Resets the current singleton reference while allowing anything with a handle on the
     *  current singleton to use that instance.
     */
    function resetContainer() {
        container = null;
    }

    /**
     * Registers the RPC hooks with the container
     */
    function registerRpcHooks() {
        container.rpcRegister('resize_iframe', resizeIframe);
        container.rpcRegister('set_title', setTitle);
        container.rpcRegister('requestNavigateTo', requestNavigateTo);
        container.rpcRegister('set_pref', setPref);
    }

    function implementViews() {

        container.views = {
            'createElementForGadget':function (metadata, rel, opt_view, opt_viewTarget, opt_coordinates, parentSite) {
                if (opt_viewTarget) {
                    return rave.createPopup(opt_viewTarget);
                }
            },


            'createElementForEmbeddedExperience':function (rel, opt_gadgetInfo, opt_viewTarget, opt_coordinates, parentSite) {
                if (opt_viewTarget) {
                    return rave.createPopup(opt_viewTarget);
                }
            },

            'createElementForUrl':function (rel, opt_viewTarget, opt_coordinates, parentSite) {
                if (opt_viewTarget) {
                    return rave.createPopup(opt_viewTarget);
                }
            },

            'destroyElement':function (site) {
                var element = site.el_;
                container.closeGadget(site);
                rave.destroyPopup(element);
            }
        };
    }

    /**
     * Validates a gadget's metadata and renders it on the page
     *
     * @param gadget the gadget object to be rendered by the container
     */
    function validateAndRenderGadget(gadget) {
        var validationResult = validateMetadata(gadget.metadata);
        if (validationResult.valid) {
            //Put our gadget metadata into the form that the common container is expecting
            var commonContainerMetadataWrapper = {};
            commonContainerMetadataWrapper[gadget.widgetUrl] = gadget.metadata;

            //Put our gadget security token data into the form that the common container is expecting
            var commonContainerTokenData = {};
            commonContainerTokenData[osapi.container.TokenResponse.TOKEN] = gadget.securityToken;
            commonContainerTokenData[osapi.container.MetadataResponse.RESPONSE_TIME_MS] = new Date().getTime();
            var commonContainerTokenWrapper = {};
            commonContainerTokenWrapper[gadget.widgetUrl] = commonContainerTokenData;

            //Setup the preloadConfig data with all our preload data
            var preloadConfig = {};
            preloadConfig[osapi.container.ContainerConfig.PRELOAD_METADATAS] = commonContainerMetadataWrapper;
            preloadConfig[osapi.container.ContainerConfig.PRELOAD_TOKENS] = commonContainerTokenWrapper;
            preloadConfig[osapi.container.ContainerConfig.PRELOAD_REF_TIME] = null;

            //Preload our data into the common container
            container.preloadCaches(preloadConfig);
            renderNewGadget(gadget);
        } else {
            rave.errorWidget(gadget.regionWidgetId, rave.getClientMessage("opensocial.render_error") + "<br /><br />" + validationResult.error);
        }
    }

    /**
     * Renders a new gadget
     * @param gadget
     */
    function renderNewGadget(gadget) {
        var widgetBodyElement = document.getElementById(["widget-", gadget.regionWidgetId, "-body"].join(""));
        gadget.site = container.newGadgetSite(widgetBodyElement);
        gadget.maximize = function (view_params) {
            // always display the gadget in canvas view even if it currently collapsed
            renderGadgetView(rave.opensocial.VIEW_NAMES.CANVAS, this, view_params);
        };
        gadget.minimize = function (view_params) {
            renderGadgetViewIfNotCollapsed(rave.opensocial.VIEW_NAMES.HOME, this, view_params);
        };
        gadget.collapse = function () {
            // hide the iframe of the gadget via css
            $(getGadgetIframeByWidgetId(this.regionWidgetId)).hide();
        };
        gadget.restore = function () {
            renderGadgetView(rave.opensocial.VIEW_NAMES.HOME, rave.getRegionWidgetById(this.regionWidgetId));
        };
        gadget.savePreferences = function (userPrefs) {
            this.userPrefs = userPrefs;
            rave.api.rest.saveWidgetPreferences({regionWidgetId:this.regionWidgetId, userPrefs:userPrefs});
            // re-render the gadget in the same view if the gadget is not collapsed
            renderGadgetViewIfNotCollapsed(rave.opensocial.getCurrentView(this.regionWidgetId), this);
        };
        gadget.editCustomPrefs = function () {
            // display the gadget in custom edit prefs view
            renderGadgetView(rave.opensocial.VIEW_NAMES.PREFERENCES, this);
        };

        // if the gadget has prefences to edit, or has the Preferences view
        // enable the edit prefs menu item
        if (gadget.metadata.hasPrefsToEdit || gadget.metadata.views.preferences) {
            if (gadget.metadata.views.preferences != undefined) {
                rave.layout.enableEditPrefsMenuItem(gadget.regionWidgetId, true);
            }
            else {
                rave.layout.enableEditPrefsMenuItem(gadget.regionWidgetId, false);
            }
        }

        // if the gadget is not collapsed, render it
        renderGadgetViewIfNotCollapsed(rave.opensocial.VIEW_NAMES.HOME, gadget);
    }

    /**
     * Utility function to render a gadget in the supplied view if the gadget's
     * collapsed attribute is false
     * @param view the OpenSocial view to render
     * @param gadget the OpenSocial gadget to render
     */
    function renderGadgetViewIfNotCollapsed(view, gadget, view_params) {
        if (!gadget.collapsed) {
            renderGadgetView(view, gadget, view_params);
        }
    }

    /**
     * Renders a gadget in the given view;
     * @param view the view to render
     * @param gadget the Rave widget object
     */
    function renderGadgetView(view, gadget, view_params) {
        var renderParams = {};
        var size = calculateSize(view, gadget);

        renderParams[osapi.container.RenderParam.VIEW] = view;
        renderParams[osapi.container.RenderParam.WIDTH] = size.width;
        renderParams[osapi.container.RenderParam.HEIGHT] = size.height;
        renderParams[osapi.container.RenderParam.USER_PREFS] = getCompleteUserPrefSet(gadget.userPrefs, gadget.metadata.userPrefs);
        container.navigateGadget(gadget.site, gadget.widgetUrl, view_params, renderParams);
    }

    function calculateSize(view, gadget) {
        var id = gadget.regionWidgetId;
        var elem = document.getElementById("widget-" + id + "-wrapper");

        // determine the height of the gadget's iframe
        var height = MIN_HEIGHT;
        if (view == rave.opensocial.VIEW_NAMES.CANVAS) {
            height = elem.clientHeight;
        } else if (gadget.metadata.modulePrefs && gadget.metadata.modulePrefs.height) {
            height = gadget.metadata.modulePrefs.height;
        }
        return {width:"100%", height:height};
    }

    /**
     * Returns the Common Container activeSiteHolder object for the given widgetId
     * @param widgetId the widgetId
     */
    function getActiveSiteHolderByWidgetId(widgetId) {
        return rave.getRegionWidgetById(widgetId).site.getActiveSiteHolder();
    }

    /**
     * Returns the iframe element of the gadget for the given widgetId
     */
    function getGadgetIframeByWidgetId(widgetId) {
        return getActiveSiteHolderByWidgetId(widgetId).getIframeElement();
    }

    /**
     * validates the metadata for the current gadget
     * @param metadata the metadata object to validate
     */
    function validateMetadata(metadata) {
        if (typeof metadata.error != "undefined") {
            return {valid:false, error:metadata.error.message};
        }

        return {valid:true};
    }

    /**
     * Combines the default user pref list from the metadata with those set by the user
     * @param setPrefs preferences already set by the user
     * @param metadataPrefs list of all available metadata objects
     */
    function getCompleteUserPrefSet(setPrefs, metadataPrefs) {
        var combined = {};
        for (var key in metadataPrefs) {
            var metaPref = metadataPrefs[key];
            var userPref = setPrefs[metaPref.name];
            combined[metaPref.name] = typeof userPref == "undefined" ? metaPref.defaultValue : userPref;
        }
        return combined;
    }

    /**
     * Gets the current view name of a gadget
     * @param regionWidgetId of the gadget
     */
    function getCurrentView(regionWidgetId) {
        // the active gadget holder will be null if the gadget is collapsed
        // as it won't be rendered on the page
        var activeGadgetHolder = getActiveSiteHolderByWidgetId(regionWidgetId);
        return (activeGadgetHolder == null) ? null : activeGadgetHolder.getView();
    }

    /*
     RPC Callback handlers
     */
    /**
     * Resizes the iFrame when gadgets.window.adjustHeight is called
     *
     * @param args the RPC event args
     */
    function resizeIframe(args) {
        var max = 0x7FFFFFFF;
        var height = args.a > max ? max : args.a;
        args.gs.setHeight(height);
    }

    /**
     * Sets the chrome title when gadgets.window.setTitle is caled
     *
     * @param args RPC event args
     */
    function setTitle(args) {

        //TODO RAVE-229: This implementation relies on parsing of the gadgetHolder's element id
        //to retrieve the module ID
        //A patch should be submitted to Shindig's common container code to properly
        //set the iFrame ID to the module id
        var bodyId = args.gs.getActiveSiteHolder().getElement().id;
        var titleId = "widget-" + rave.getObjectIdFromDomId(bodyId) + "-title";
        var element = document.getElementById(titleId);
        if (element) {
            var a = isArray(args.a) ? args.a[0] : args.a;
            element.innerHTML = gadgets.util.escapeString(a);
        }

    }

    /**
     * Saves a userPref for the widget
     *
     * @param args RPC event args
     * @param editToken this is an old deprecated parameter but still needs to be in the signature for proper binding
     * @param prefName the userpref name
     * @param prefValue the userpref value
     */
    function setPref(args, editToken, prefName, prefValue) {
        var widgetId = rave.getObjectIdFromDomId(args.gs.getActiveSiteHolder().getElement().id);
        var regionWidget = rave.getRegionWidgetById(widgetId);
        // update the memory prefs object
        regionWidget.userPrefs[prefName] = prefValue;
        // persist it to database
        rave.api.rest.saveWidgetPreference({regionWidgetId:widgetId, userPref:{prefName:prefName, prefValue:prefValue}});
    }

    /**
     * Re-renders the gadget in the requested view
     *
     * @param args RPC event args
     * @param viewName the view name to render
     */
    function requestNavigateTo(args, viewName, opt_params, opt_ownerId) {
        var widgetId = rave.getObjectIdFromDomId(args.gs.getActiveSiteHolder().getElement().id);
        var fnArgs = {};
        fnArgs.data = {}
        fnArgs.data.id = widgetId;

        switch (viewName) {
            case VIEW_NAMES.CANVAS:
                rave.maximizeWidget(fnArgs, opt_params);
                break;
            case VIEW_NAMES.HOME:
                rave.minimizeWidget(fnArgs, opt_params);
                break;
            case VIEW_NAMES.PREFERENCES:
                rave.editCustomPrefs(fnArgs);
                break;
        }
    }

    /**
     * Utility functions
     */
    function isArray(o) {
        return Object.prototype.toString.call(o) == "[object Array]";
    }


    /**
     * Exposed public API calls
     */
    return {
        TYPE:WIDGET_TYPE,

        VIEW_NAMES:VIEW_NAMES,

        VIEW_TARGETS: VIEW_TARGETS,
        /**
         * Initializes the Rave OpenSocial machinery
         */
        init:initOpenSocial,
        /**
         * Gets a reference to the container singleton
         */
        container:getContainer,
        /**
         * Instantiates and renders the given gadget
         * @param a gadget to render
         */
        initWidget:validateAndRenderGadget,

        /**
         * Resets the current OpenSocial container
         */
        reset:resetContainer,
        /**
         * Gets the current view name of the given gadget
         * @param regionWidgetId of the gadget
         */
        getCurrentView:getCurrentView
    };

})();

//Register the widget provider with Rave
rave.registerProvider(rave.opensocial);
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var rave = rave || {};
rave.personprofile = rave.personprofile || (function() {
    // map of [subpage id, boolean] tracking whether or not a sub page has been viewed at least once
    var subPagesViewedStatus = {};
     function initSubPages() {
        //Make first tab active (Twitter Bootstrap)
        $('.nav-tabs a:first').tab('show');
        $('#personProfileSubPages a[data-toggle="tab"]').on('shown', function(event, ui) {
            // refresh the widgets on the sub page when selected to ensure proper sizing
            var subPageId = $( $(this).attr("href") ).attr("id");
            if (subPagesViewedStatus[subPageId] == false) {
                $("#" + subPageId + " .widget-wrapper").each(function(){
                    var regionWidget = rave.getRegionWidgetById(rave.getObjectIdFromDomId(this.id));
                    regionWidget.restore();
                });
                // mark that this sub page has been viewed at least once and there is no need to refresh
                // the widgets in future views
                subPagesViewedStatus[subPageId] = true;
            }
        });
        // build the subPageViewedStatus map to track if a given sub page has been viewed yet to determine if we need
        // to refresh the widgets upon first viewing to ensure they are sized properly.  Set the default active tab to
        // true since it will be rendered and sized properly as part of the initial page load
        var activeSubPageId = $("#personProfileSubPages .tab-pane.active")[0].id;
        $("#personProfileSubPages .tab-pane").each(function(){
            subPagesViewedStatus[this.id] = (this.id == activeSubPageId);
        });
    }

    function initButtons() {
        // setup the edit button if it exists
        var $editButton = $("#profileEdit");
        if ($editButton) {
            $editButton.click(function() {
                rave.api.handler.userProfileEditHandler(true);
            });
        }

        // setup the cancel button if it exists
        var $cancelButton = $("#cancelEdit");
        if ($cancelButton) {
            $cancelButton.click(function() {
                rave.api.handler.userProfileEditHandler(false);
            });
        }
    }

	function init() {
        initSubPages();
        initButtons();
    }
	
	return {
        init : init
    };
}());
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var rave = rave || {};
rave.store = rave.store || (function() {

    function initRatings() {
        $('.ratingButtons').button();
        $('.widgetLikeButton').click(function() {
            // If not already active
            if (!$(this).hasClass('active')){
                //retrieve widget id
                var widgetId = this.id.substring("like-".length);

                //update the widget score in database
        		rave.api.rest.updateWidgetRating({widgetId: widgetId, score: 10});

                //call update widget rating handler function
                var widgetRating = {
                    widgetId: widgetId,
                    widgetLikeButton: this,
                    widgetDislikeButton: $("#dislike-" + widgetId),
                    isLike: true
                };

                //update the widget ratings on web page
                rave.api.handler.widgetRatingHandler(widgetRating);

                $(this).addClass('btn-success');
                $(this).siblings('.btn').removeClass('btn-danger');
            }
        });

        $('.widgetDislikeButton').click(function() {
            // If not already active
            if (!$(this).hasClass('active')){
                //retrieve widget id
                var widgetId = this.id.substring("dislike-".length);

                //update the widget score in database
                rave.api.rest.updateWidgetRating({widgetId: widgetId, score: 0});

                //call update widget rating handler function
                var widgetRating = {
                    widgetId: widgetId,
                    widgetLikeButton: $("#like-" + widgetId),
                    widgetDislikeButton: this,
                    isLike: false
                };

                //update the widget ratings on web page
                rave.api.handler.widgetRatingHandler(widgetRating);

                $(this).addClass('btn-danger');
                $(this).siblings('.btn').removeClass('btn-success');

            }
        });
    }

    function initComments() {

        $(".commentNewButton").button( {
            icons: {primary: "ui-icon-disk"},
            text: false
        }).click(function() {
            var widgetId = this.id.substring("comment-new-".length);
            rave.api.rest.createWidgetComment({widgetId: widgetId,
                                                text: $("#newComment-"+widgetId).get(0).value,
                                                successCallback: function() { window.location.reload(); }});
        });

        $(".commentDeleteButton").button( {
            icons: {primary: "ui-icon-close"},
            text: false
        }).click(function() {
            var commentId = this.id.substring("comment-delete-".length);
            var widgetId = this.getAttribute('data-widgetid');
                rave.api.rest.deleteWidgetComment({widgetId: widgetId,
                                                commentId: commentId,
                                                successCallback: function() { window.location.reload(); }});
        });

        $(".commentEditButton").click(function() {
            var commentId = this.id.substring("comment-edit-".length);
            var widgetId = this.getAttribute('data-widgetid');
            var commentText = $(this).parents(".comment").find(".commentText").text();
            $("#editComment").html(commentText);
            $("#editComment-dialog #updateComment").click( function(){
                rave.api.rest.updateWidgetComment({widgetId: widgetId,
                    commentId: commentId,
                    text: $("#editComment").get(0).value,
                    successCallback: function() { window.location.reload(); }
                });
            }).html(rave.getClientMessage("common.update"));
        });
    }

    function initTags(widgetId) {
        $('*[data-toggle="basic-slide"]').click(function(){
            var target;

            if($(this).attr("data-target")){
                target = $(this).attr("data-target");
                console.log($(this).attr("data-target"));
            }
            else{
                target = $(this).attr("href");
                console.log("else");
            }

            if($(this).attr('data-toggle-text')){
                var oldcontent = $(this).html();
                $(this).html($(this).attr('data-toggle-text'));
                $(this).attr('data-toggle-text',oldcontent);
            }
            $(target).slideToggle();
        });
        $(".tagNewButton").click(function () {
                var widgetId = this.id.substring("tag-new-".length);
                rave.api.rest.createWidgetTag({widgetId:widgetId,
                    text:$("#tags").get(0).value,
                    successCallback:function () {
                        window.location.reload();
                    }});
            });
        //    load the tag by widgetId
        rave.api.rest.getTags({ widgetId:widgetId,
            successCallback:function (data) {
                var result = ($.map(data, function (tag) {
                    return {
                        label:tag.keyword,
                        value:tag.keyword
                    }
                }));
                $("#tags").typeahead({
                    source:result
                })
            }
        })
    }

    function initWidgetsTag(referringPageId) {
        if (referringPageId != null){
            // tag list box
            $("#tagList").change(function() {
                var selected = $("#tagList option:selected").text();
                selected=$.trim(selected)
                if (selected.length > 1) {
                    document.location.href = rave.getContext() + "store/tag?keyword=" + selected
                           +"&referringPageId="+referringPageId;
                }
            });
        }
    }

    function initWidgetsCategory(referringPageId) {
        if (referringPageId != null){
            // category list box
            $("#categoryList").change(function() {
                var selected = $("#categoryList option:selected").val();
                selected = parseInt(selected);
                if (!isNaN(selected)) {
                   document.location.href = rave.getContext() + "store/category?categoryId=" + selected
                           +"&referringPageId="+referringPageId;
                }
            });
        }
    }

    function init(referringPageId){
        initRatings();
        initComments();
        initWidgetsTag(referringPageId);
        initWidgetsCategory(referringPageId);
    }

    return {
        init: init,
        initTags: initTags
    };

}());
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var rave = rave || {};
rave.wookie = rave.wookie || (function() {
    var WIDGET_TYPE = "W3C";
    var OFFSET = 10;
    var MIN_HEIGHT = 250;
    // keep this value so we can show the widget in the maximize view even when its collapsed
    var userCollapsed;
    var container;
    
    
    function onClientSecurityAlert(source, alertType) {  /* Handle client-side security alerts */  }
    function onClientConnect(container) {        /* Called when client connects */   }
    function onClientDisconnect(container) {     /* Called when client disconnects */ }

    function validateAndRenderWidget(widget){
    	userCollapsed = widget.collapsed;
        var widgetBodyElement = document.getElementById(["widget-", widget.regionWidgetId, "-body"].join(""));
        
        var height = MIN_HEIGHT;
        if (widget.height) height = widget.height;
        
        //
        // Create a global onload callback handler for making the widget
        // visible after its container is ready
        //
        window["onWidget"+widget.regionWidgetId+"Load"] = function(){
           window.document.getElementById(widget.regionWidgetId).style.visibility="visible";
        };

        //
        // Create OpenAjax IFrame container
        //
        var ooacontainer = new OpenAjax.hub.IframeContainer(rave.getManagedHub() , ""+widget.regionWidgetId,
        {
          Container: {
            onSecurityAlert: onClientSecurityAlert,
            onConnect:       onClientConnect,
            onDisconnect:    onClientDisconnect
          },
          IframeContainer: {
            parent:      widgetBodyElement, 
            iframeAttrs: { 
                style: { width:"100%"},
                vspace: 0,
                hspace: 0,
                marginheight: 0,
                marginwidth: 0,
                scroll: "no",
                frameborder: 0,
                height: height,
                "min-height": ""+MIN_HEIGHT+"px"
            },
            uri: widget.widgetUrl,
            onGadgetLoad: "onWidget"+widget.regionWidgetId+"Load"
          }
        }
        );
        
        // collapse/restore functions
        widget.collapse = function() {
            $(ooacontainer.getIframe).hide();
        };
        widget.restore = function() {
            $(ooacontainer.getIframe).show();
        };
        widget.maximize = function() {
            // always display the widget in canvas view even if it currently collapsed
            if (widget.collapsed){
                userCollapsed = true;
                $(ooacontainer.getIframe).show();
            }
        };
        widget.minimize = function() {
            if (widget.collapsed){
                userCollapsed = false;
                $(ooacontainer.getIframe).hide();
            }
        };
        // if in the collapsed state, hide the layer
        if (widget.collapsed){
            $(ooacontainer.getIframe).hide();
        }
    }

    /**
     * Exposed public API calls
     */
    return {
        TYPE : WIDGET_TYPE,

        /**
         * Init function required by Rave's initialization infrastructure
         */
        init : function() {},
        /**
         * Instantiates and renders the given widget
         * @param a widget to render
         */
        initWidget: validateAndRenderWidget

    };


})();

//Register the widget provider with Rave
rave.registerProvider(rave.wookie);
